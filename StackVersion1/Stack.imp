template <class T>
inline Stack<T>::Stack(const Stack<T>& s)
{
    copy(s);
}

template <class T>
inline Stack<T>& Stack<T>::operator=(const Stack<T>& s)
{
    if(this != &s)
    {
        delete [] arr;
        copy(s);
    }

    return *this;
}

template <class T>
inline Stack<T>::~Stack()
{
    delete [] arr;
}

template <class T>
inline const T& Stack<T>::top() const
{
    if(!isEmpty())
    {
        return arr[tos-1];
    }
    else
    {
        throw "Stack is empty";
    }
}

template <class T>
inline void Stack<T>::pop()
{
    if(!isEmpty())
    {
        tos--;
    }
    else
    {
        throw "Stack is empty";
    }
}

template <class T>
inline void Stack<T>::push(const T& element)
{
    checkSize();
    arr[tos++] = element;
}

template <class T>
inline bool Stack<T>::isEmpty() const
{
    return tos == 0;
}

template <class T>
inline void Stack<T>::resize(int newCapacity)
{
    T* buff = new T[newCapacity];
    for(int i = 0; i < tos; ++i)
    {
        buff[i] = arr[i];
    }

    delete [] arr;

    arr = buff;
    capacity = newCapacity;
}

template <class T>
inline void Stack<T>::checkSize()
{
    if(tos == capacity)
    {
        resize(capacity ? capacity*2 : 2);
    }
}

template <class T>
inline void Stack<T>::copy(const Stack<T>& s)
{
    arr = new T[s.tos];
    for(int i = 0; i < s.tos; ++i)
    {
        arr[i] = s.arr[i];
    }
    tos = s.tos;
    capacity = s.capacity;
}
